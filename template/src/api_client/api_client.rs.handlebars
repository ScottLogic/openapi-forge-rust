{{setVar "cabi" _options.[generator.cabi]}}
{{#ifEquals _options.[generator.cabi] "true"}}
use abi_stable::std_types::RHashMap as HashMap;
{{/ifEquals}}
{{#ifNotEquals _options.[generator.cabi] "true"}}
use std::collections::HashMap;
{{/ifNotEquals}}


use reqwest::Client;
use reqwest::Url;

use crate::config::Configuration;
use crate::{response::ForgeResponse, model::*};

{{#ifEquals _options.[generator.cabi] "true"}}
use abi_stable::std_types::string::RString as String;
use abi_stable::std_types::ROption as Option;
#[allow(unused_imports)]
use abi_stable::std_types::vec::RVec as Vec;
use async_ffi::{FfiFuture, FutureExt};
{{/ifEquals}}

{{#ifEquals _options.[generator.cabi] "true"}}
#[repr(C)]
{{/ifEquals}}
pub struct ApiClient{{_tag.name}} {
    config: Configuration,
    client: Client,
}

impl ApiClient{{_tag.name}} {
    pub fn new(config: Configuration, client: Client) -> Self{
        ApiClient{{_tag.name}} { config, client }
    }
    {{#each paths}}
    {{~setVar "path" @key}}
    {{~#each this}}
    {{~#ifEquals ../../_tag.name _tag.name}}
    {{~#if (pathContentTypeSupported this)}}
    {{#if summary}}
    // <summary>
    // {{summary}}
    // </summary>
    {{/if}}
    {{#if description}}
    // {{description}}
    {{/if}}
    {{#if tags}}
    // <tags>{{tags}}</tags>
    {{/if}}
    {{#each _sortedParameters}}
    // <param name="{{name}}">{{description}}</param>
    {{/each}}
    pub async fn {{toRustParamName operationId}} (
        &self, 
        {{~#each _sortedParameters ~}}
            {{#ifEquals required true}}
                {{toRustParamName name ~}}: {{~safeTypeConvert schema true}},
            {{else}}
                {{toRustParamName name ~}}: {{~safeTypeConvert schema false}},
            {{/ifEquals}}
        {{~/each ~}}
    ) -> ForgeResponse<{{safeTypeConvert _response.schema true}}>
    {
        {{#each _sortedParameters}}
            {{#if (hasDefault schema)}}
            // Set default value for {{toRustParamName name}}
            let {{toRustParamName name ~}} = if ({{toRustParamName name ~}}.is_none()) { {{getSome @root.cabi}} ({{{quoteIfString schema.default}}}.into()) } else { status }; 
            {{/if ~}}
        {{/each}}
        let url = self.config.get_base_address() + {{{setPathParameters @root.path _sortedParameters @root.cabi}}};
        let request_uri = Url::parse(&url).unwrap();
        {{#if (queryParametersExist _sortedParameters)}}
        {{createQueryStringSnippet _sortedParameters @root.cabi}}
        {{/if}}
        let response = self.client.{{@key}}(request_uri)
        {{#if (queryParametersExist _sortedParameters)}}
        .query(&query_params)
        {{/if}}
        {{#if (bodyParameterExists _sortedParameters)}}
        .json(&body)
        {{/if}}
        .send()
        .await.unwrap();
        let status_code = response.status().as_u16();
        let headers = response
            .headers()
            .iter()
            .map(|(k, v)| (k.to_string().into(), v.to_str().unwrap().into()))
            .collect::<HashMap<_, _>>();
        let data = response.json::<{{safeTypeConvert _response.schema true}}>().await.unwrap();
        ForgeResponse::new(data, status_code, headers )
    }
    {{else}}
    #[allow(unused_variables)]
    pub fn {{toRustParamName operationId}} (
        {{~#each _sortedParameters ~}}
            {{#ifEquals _response.required true}}
                {{toRustParamName name ~}}: {{~safeTypeConvert schema true}},
            {{else}}
                {{toRustParamName name ~}}: {{~safeTypeConvert schema false}},
            {{/ifEquals}}
        {{~/each ~}}
    ) -> ForgeResponse<{{safeTypeConvert _response.schema true}}>
    {
        panic!("Operation `{{toRustParamName operationId}}` most likely does not support json encoded requests which are not supported by openapi forge.", );
    }    
    {{/if}}
    {{/ifEquals}}
    {{/each}}  
    {{/each}}
}


{{#ifEquals _options.[generator.cabi] "true"}}
#[no_mangle]
pub extern "C" fn c_api_client{{toRustParamName _tag.name}}_new(
    config: Box<Configuration>,
    client: Box<Client>,
) -> Box<ApiClient{{_tag.name}}>{
    Box::new(ApiClient{{_tag.name}} { config: *config, client: *client })
}
{{#each paths}}
{{~setVar "path" @key}}
{{~#each this}}
{{~#ifEquals ../../_tag.name _tag.name}}
{{~#if (pathContentTypeSupported this)}}
#[no_mangle]
pub extern "C" fn c_api_client{{toRustParamName _tag.name}}_{{toRustParamName operationId}} (
    api_client: Box<ApiClient{{_tag.name}}>,
    {{~#each _sortedParameters ~}}
        {{#ifEquals required true}}
            {{toRustParamName name ~}}: {{~safeTypeConvert schema true}},
        {{else}}
            {{toRustParamName name ~}}: {{~safeTypeConvert schema false}},
        {{/ifEquals}}
    {{~/each ~}}
) -> FfiFuture<ForgeResponse<{{safeTypeConvert _response.schema true}}>> {
    async move {
        api_client.{{toRustParamName operationId}}(
        {{~#each _sortedParameters ~}}
            {{#ifEquals required true}}
                {{toRustParamName name ~}},
            {{else}}
                {{toRustParamName name ~}},
            {{/ifEquals}}
        {{~/each ~}}
        ).await
    }
    .into_ffi()
}
{{/if}}
{{/ifEquals}}
{{/each}}  
{{/each}}
{{/ifEquals}}