{{#if description}}
/**
* <summary>{{description}}</summary>
*/
{{/if}}
#[derive(Serialize, Deserialize, Debug{{#ifEquals @root.cabi "true"}}, Default{{/ifEquals}})]
{{#ifEquals @root.cabi "true"}}
#[repr(C)]
{{/ifEquals}}
pub struct {{toClassName @key}} 
{
  {{#each properties}}
    {{#if description}}
    // <value>
    // {{description}}
    // <value>
    {{/if}}
    {{#if example}}
    // <example>
    // {{example}}
    // <example>
    {{/if}}
    {{~#ifContains ../required @key~}}
    {{setVar "is_required" true}}
    {{~else~}}
    {{setVar "is_required" false}}
    {{~/ifContains~}}
    {{#ifNotEquals (toRustParamName @key) @key }}
    #[serde(rename = "{{@key}}")]
    {{/ifNotEquals}}
    pub {{toRustParamName @key}}: {{{safeTypeConvert this @root.is_required}}},
  {{/each}}
}

{{#ifEquals @root.cabi "true"}}
// We can pass the object by reference normally but with ffi, this indicates using *mut (mutable pointers) which we can avoid by passing values. 
#[no_mangle]
pub extern "C" fn c{{toRustParamName @key}}_type_name_of_object(o: Box<ForgeResponse<{{toClassName @key}}>>) -> FFISafeTuple<{{toClassName @key}}> {
    // Does nothing but references each field of the struct as a verification
    let type_name = get_type_name(&o);
    FFISafeTuple::<{{toClassName @key}}>(o,type_name)
}

#[no_mangle]
pub extern "C" fn c{{toRustParamName @key}}_type_information() -> Box<ObjectTypeInformation> {
    let o = {{toClassName @key}}::default();
    let type_name = get_type_name(&o);
    let {{#each properties}}{{#if @last}}mut{{/if}}{{/each}} map = HashMap::new();
    {{#each properties}}
    let field_type_name = get_type_name(&o.{{toRustParamName @key}});
    map.insert("{{toRustParamName @key}}".into(), field_type_name);
    {{/each}}
    let type_information = ObjectTypeInformation { type_name, fields: map};
    Box::new(type_information)
}
{{/ifEquals}}
